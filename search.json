[{"title":"使用 acme.sh 安装 Let’ s Encrypt 提供的免费 SSL 证书","url":"/jingjie.github.io/2019/11/29/使用-acme-sh-安装-Let’-s-Encrypt-提供的免费-SSL-证书/","content":"\n# 方式一\n----\n\n### 测试环境\n\nUbuntu 18.04\n\nNginx\n\n----\n\n### 准备\n\n+ 开放云服务器 443 端口\n+ 开放系统 443 端口\n\nNote：https 成功后，记得把网站所有连接换成 https\n\n----\n\n### 1. 介绍\n\nLet’ s Encrypt已有免费的证书可用，以后的网站估计都要上https的吧，所以把我的网站上的证书换了一下，这节主要是参考使用 acme.sh 给 Nginx 安装 Let’ s Encrypt 提供的免费 SSL 证书这篇文章，并结合自己的情况，把我的经验记录下来。\n\n### 2. 安装\n\n我们使用acme.sh来申请和管理证书，它很简单用，还能够利用crontab自动更新证书，而且是默认就有的功能。\n\n首先安装：\n\n```shell\n1、cd\n2、wget -O -  https://get.acme.sh | sh\n3、cd .acme.sh\n```\n\n安装完之后，可以退出登录，再重新登录，或者执行一下**『source ~/.bashrc』**。\n\n之后就可以使用 **acme.sh** 命令了。\n\n### 3. 申请证书\n\n首先申请和下载证书：\n\n```shell\n# -w 后面写上你自己的网站根目录 -d 自己的网站域名\n./acme.sh --issue -d www.nicefutureworld.com -w /home/wwwroot/www.nicefutureworld.com/current/public\n```\n\n申请成功后，证书会被保存在 .acme.sh 目录里面的 www.nicefutureworld.com  目录里面：\n\n![fc61f2da01de2d5389a4e5e0f6e9119.png](https://www.nicefutureworld.com/storage/article/2019/07/25/5gbruO0pn4Ln71CQSGj3q9UWbs7lEXRNv5mMg4Vh.png)\n\n接下来我们要把证书安装到你的应用中：\n\n```shell\n# ssl 文件夹不存在则先创建，需要有写的权限\n./acme.sh --installcert -d boat.rails365.net \\\n               --keypath       /home/wwwroot/www.nicefutureworld.com/ssl/www.nicefutureworld.com.key  \\\n               --fullchainpath /home/wwwroot/www.nicefutureworld.com/ssl/www.nicefutureworld.com.key.pem \\\n               --reloadcmd     \"sudo lnmp reload\"\n```\n\n接下来，还需要再生成一个文件，很多ssl的配置都需要它：\n\n```\nopenssl dhparam -out /home/wwwroot/www.nicefutureworld.com/ssl/dhparam.pem 2048\n```\n\n### 4. nginx配置\n\n```\nupstream boat_manager {\n\tserver unix:///home/wwwroot/www.nicefutureworld.com/shared/tmp/sockets/puma.sock fail_timeout=0;\n}\n\nserver {\n\tlisten 443 ssl;\n\tserver_name www.nicefutureworld.com;\n\tssl_certificate         /home/wwwroot/www.nicefutureworld.com/ssl/www.nicefutureworld.com.key.pem;\n\tssl_certificate_key     /home/wwwroot/www.nicefutureworld.com/ssl/www.nicefutureworld.com.key;\n\t# ssl_dhparam\n\tssl_dhparam             /home/wwwroot/www.nicefutureworld.com/ssl/dhparam.pem;\n\troot /home/wwwroot/www.nicefutureworld.com/current/public\n\tkeepalive_timeout 70;\n\t# 其它配置保持不变\n}\n\nserver {\n    listen 80;\n    server_name www.nicefutureworld.com;\n    return 301 https://www.nicefutureworld.com$request_uri;\n}\n```\n\n顶层的http指令那里，也需要加上这两行：\n\n```\nhttp {\n    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n    ssl_prefer_server_ciphers on;\n}\n```\n\n原文地址：[https://www.qiuzhi99.com/articles/shi-yong-acme-sh-an-zhuang-let-s-encrypt-ti-gong-mian-fei-ssl-zheng-shu](https://www.qiuzhi99.com/articles/shi-yong-acme-sh-an-zhuang-let-s-encrypt-ti-gong-mian-fei-ssl-zheng-shu)\n\n\n# 方式二\n\n准备：\n\n>先停止 Nginx\n\n使用：https://certbot.eff.org\n\n选择自己的环境与系统：如 Nginx Ubuntu18.04\n\n![ab86c122dfd676d9b6756551565213f.png](https://www.nicefutureworld.com/storage/article/2019/07/25/C1kZHFtlEJ2AVSpUu8jZQlqZAjxNBJl2DZyz7KNu.png)\n\n接下来就是按文档步骤操作：操作完以后把 Nginx 配置跟上一样\n\n![e4bad6e0104596364783869c266cebb.png](https://www.nicefutureworld.com/storage/article/2019/07/25/TT9wnAovZTQ0zMhUMxQQCFlnWUjM3ksb36eC7giu.png)\n\n![c4f9fe7af9bda18f4fa28453ee554fa.png](https://www.nicefutureworld.com/storage/article/2019/07/25/5Bc64yUdqCG0XyzFTENee7x9sTzsSpshOEhC5xAB.png)\n\n![e835c2150102fdeefeaf207bf03bb5c.png](https://www.nicefutureworld.com/storage/article/2019/07/25/qNv7XHvzONrAWSat9yA7JUvG8yoHhLUvCVWFFk4V.png)"},{"title":"MySQL SQL 查询执行流程","url":"/jingjie.github.io/2019/11/29/MySQL-SQL-查询执行流程/","content":"\n## 流程图\nMySQL 大体可分为 server 层与 存储引擎\n\n## 流程解释\n\n#### 1、连接器\n管理连接，权限验证，当一个连接权限验证通过后，即使你使用管理员对这个用户的权限做了修改，对已经通过验证的接连也不会生效。只有新连接才会使用新的权限\n\n### 2、查询缓存\n命中则直接返回结果，缓存以 key=>value 的形式储存，key 为 SQL 语句，value 为查询的结果，查询缓存当出现更新时，当前表的所有缓存将被清空。\n\n**Note：**因查询缓存往往弊大于利 MySQL 8 及以上版本查询缓存已经被抛弃\n\n### 3、分析器\n对 SQL 进程词法语法分析，并验证表与查询的字段是否存在\n\n### 4、优化器\n对 SQL 进行索引选择\n\n### 5、执行器\n执行 SQL 语句，查询存储引擎，返回结果"},{"title":"【缓存穿透、缓存击穿、缓存雪崩、热点数据失效】问题的解决方案","url":"/jingjie.github.io/2019/11/29/【缓存穿透、缓存击穿、缓存雪崩、热点数据失效】问题的解决方案/","content":"\n### 阿里一面：关于【缓存穿透、缓存击穿、缓存雪崩、热点数据失效】问题的解决方案\n\n来自：石杉的架构笔记\n\n### 1、前言\n\n昨天晚上接到阿里的电面电话，过程中就问到了关于缓存相关的问题。\n\n虽然以前接触过，多多少少了解了一些。但是之前自己并没有好好记录这些内容，在真正面试的时候，并没有回答得出来。今天记录一下，长长记性。\n\n在我们的平常的项目中多多少少都会使用到缓存，因为一些数据我们没有必要每次查询的时候都去查询到数据库。\n\n特别是高 QPS 的系统，每次都去查询数据库，对于你的数据库来说将是灾难。\n\n今天我们不牵涉多级缓存的知识，就把系统使用到的缓存方案，不管是一级还是多级的都统称为缓存，主要是为了讲述使用缓存的时候可能会遇到的一些问题以及一些解决办法。\n\n当我们查询一条数据时，先去查询缓存，如果缓存有就直接返回，如果没有就去查询数据库，然后返回。这种情况下就可能会出现一些现象。\n\n### 2、缓存穿透\n\n##### 2.1 什么是缓存穿透\n\n正常情况下，我们去查询数据都是存在。\n\n那么请求去查询一条压根儿数据库中根本就不存在的数据，也就是缓存和数据库都查询不到这条数据，但是请求每次都会打到数据库上面去。\n\n这种查询不存在数据的现象我们称为缓存穿透。\n\n##### 2.2 穿透带来的问题\n\n试想一下，如果有黑客会对你的系统进行攻击，拿一个不存在的id 去查询数据，会产生大量的请求到数据库去查询。可能会导致你的数据库由于压力过大而宕掉。\n\n##### 2.3 解决方案\n\n+ 1、缓存空值\n\n\t> 之所以会发生穿透，就是因为缓存中没有存储这些空数据的 key。从而导致每次查询都到数据库去了。\n\n\t> 那么我们就可以为这些 key 对应的值设置为 null 丢到缓存里面去。后面再出现查询这个 key 的请求的时候，直接返回 null 。\n\n\t> 这样，就不用在到数据库中去走一圈了，但是别忘了设置过期时间。\n\n+ 2、BloomFilter （布隆过滤器）\n\n\t> BloomFilter 类似于一个hbase set 用来判断某个元素（key）是否存在于某个集合中。\n\n\t> 这种方式在大数据场景应用比较多，比如 Hbase 中使用它去判断数据是否在磁盘上。还有在爬虫场景判断url 是否已经被爬取过。\n\n\t> 这种方案可以加在第一种方案中，在缓存之前在加一层 BloomFilter ，在查询的时候先去 BloomFilter 去查询 key 是否存在，如果不存在就直接返回，存在再走查缓存 -> 查 DB。\n\n##### 2.4 如何选择\n\n针对于一些恶意攻击，攻击带过来的大量 key 是不存在的，那么我们采用第一种方案就会缓存大量不存在 key 的数据。\n\n此时我们采用第一种方案就不合适了，我们完全可以先对使用第二种方案进行过滤掉这些 key。\n\n针对这种 key 异常多、请求重复率比较低的数据，我们就没有必要进行缓存，使用第二种方案直接过滤掉。\n\n而对于空数据的 key 有限的，重复率比较高的，我们则可以采用第一种方式进行缓存\n\n### 3、缓存击穿\n\n##### 3.1 什么是击穿\n\n缓存击穿是我们可能遇到的第二个使用缓存方案可能遇到的问题。\n\n在平常高并发的系统中，大量的请求同时查询一个 key 时，此时这个 key 正好失效了，就会导致大量的请求都打到数据库上面去。这种现象我们称为 **缓存击穿**。\n\n##### 3.2 会带来什么问题\n\n会造成某一时刻数据库请求量过大，压力剧增。\n\n##### 3.3 如何解决\n\n上面的现象是多个线程同时去查询数据库的这条数据，那么我们可以在第一个查询数据的请求上使用一个 互斥锁来锁住它。\n\n其他的线程走到这一步拿不到锁就等着，等第一个线程查询到了数据，然后做缓存。后面的线程进来发现已经有缓存了，就直接走缓存。\n\n### 4、缓存雪崩\n\n##### 4.1 什么是缓存雪崩\n\n缓存雪崩的情况是说，当某一时刻发生大规模的缓存失效的情况，比如你的缓存服务宕机了，会有大量的请求进来直接打到DB上面。结果就是DB 称不住，挂掉\n\n##### 4.2 解决方案\n\n+ 1、事前： 使用集群缓存，保证缓存服务的高可用\n\n\t> 这种方案就是在发生雪崩前对缓存集群实现高可用，如果是使用 Redis，可以使用 主从+哨兵 ，Redis Cluster 来避免 Redis 全盘崩溃的情况。\n\n+ 2、事中：ehcache 本地缓存 + Hystrix 限流 & 降级,避免 MySQL 被打死\n\n\t> 使用 ehcache 本地缓存的目的也是考虑在 Redis Cluster 完全不可用的时候，ehcache 本地缓存还能够支撑一阵。\n\n\t> 使用 Hystrix进行限流 & 降级 ，比如一秒来了5000个请求，我们可以设置假设只能有一秒 2000个请求能通过这个组件，那么其他剩余的 3000 请求就会走限流逻辑。\n\n\t> 然后去调用我们自己开发的降级组件（降级），比如设置的一些默认值呀之类的。以此来保护最后的 MySQL 不会被大量的请求给打死。\n\n+ 3、事后：开启Redis持久化机制，尽快恢复缓存集群\n\n\t一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。\n\n### 5、解决热点数据集中失效问题\n\n我们在设置缓存的时候，一般会给缓存设置一个失效时间，过了这个时间，缓存就失效了。\n\n对于一些热点的数据来说，当缓存失效以后会存在大量的请求过来，然后打到数据库去，从而可能导致数据库崩溃的情况。\n\n##### 5.1 解决方案\n\n+ 1、设置不同的失效时间\n\n\t> 为了避免这些热点的数据集中失效，那么我们在设置缓存过期时间的时候，我们让他们失效的时间错开。\n\n\t> 比如在一个基础的时间上加上或者减去一个范围内的随机值。\n\n+ 2、互斥锁\n\n\t> 结合上面的击穿的情况，在第一个请求去查询数据库的时候对他加一个互斥锁，其余的查询请求都会被阻塞住，直到锁被释放，从而保护数据库。\n\n\t> 但是也是由于它会阻塞其他的线程，此时系统吞吐量会下降。需要结合实际的业务去考虑是否要这么做。"},{"title":"Linux 性能分析工具图","url":"/jingjie.github.io/2019/11/29/Linux-性能分析工具图/","content":"\n这个图是 Linux 性能分析最重要的参考资料之一，它告诉你 Linux 不同子系统出现性能问题，应该使用什么样的工具来观察与分析，比如 IO 性能问题，可能参考 IO 子系统，可以使用 iostat、iotop、blktrace等工具分析磁盘 IO 的瓶颈\n\n![file](https://cdn.learnku.com/uploads/images/201902/26/23047/ZFqUsfY97n.png!large)\n\n![file](https://cdn.learnku.com/uploads/images/201902/26/23047/KjnB62oumY.png!large)\n\n![file](https://cdn.learnku.com/uploads/images/201902/26/23047/lSPhVAMDuI.png!large)"},{"title":"Laravel job 进程管理工具 Supervisor","url":"/jingjie.github.io/2019/11/29/Laravel-job-进程管理工具-Supervisor/","content":"\n## 系统\n\nCentOS Linux release 7.4.1708\nHomestead 4.15 Ubuntu 18.04 LTS\n\n## Supervisor 安装\n\neasy_install supervisor\n\n```shell\nsudo easy_install supervisor\n```\n\n## Supervisor 配置\n\n1、生成新主配置文件\n\n```shell\necho_supervisord_conf > /etc/supervisord.conf // 需要 root 限制，sudo 不管用\n```\n\n2、修改 supervisord.conf 主配置文件\n\n```shell\n·\n·\n[unix_http_server]\nfile=/var/run/supervisor.sock   ; the path to the socket file\n·\n·\n[supervisorctl]\nserverurl=unix:///var/run/supervisor.sock ; use a unix:// URL  for a unix socket\n·\n·\n[supervisord]\nlogfile=/var/log/supervisord.log ; main log file; default $CWD/supervisord.log\n·\n·\npidfile=/var/run/supervisord.pid ; supervisord pidfile; default supervisord.pid\n·\n·\n[include]\nfiles = /etc/supervisor/*.conf\n```\n\n3、启动 supervisor（确保9001端口未被占用）\n\n```shell\nsudo supervisord -c /etc/supervisord.conf\n```\n\n4、创建第二步对应的文件\n\n```shell\nsudo touch  /var/run/supervisor.sock\nsudo chmod 777 /var/run/supervisor.sock\nsudo touch /var/log/supervisord.log  // 已经存在再次创建也没影响\nsudo chmod 777 /run\nsudo chmod 777 /var/log\n```\n\n5、创建 supervisor 项目配置文件\n\n```shell\n// 查看 /etc/supervisord.conf 文件\n[include]\nfiles = /etc/supervisor/*.conf // 这个路径放置项目对应的 supervisor 配置文件\n```\n\n```shell\n// 在 /etc/supervisor/ 目录下创建以 laravel-worker.conf配置文件（以 .conf 结尾即可)，内容如下\n[program:laravel-worker]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=php /data/www/laravel/artisan queue:work --sleep=3 --tries=3\nautostart=true\nautorestart=true\nuser=vagrant\nnumprocs=8\nredirect_stderr=true\nstdout_logfile=/var/log/supervisor/laravel-queue.log // 配置文件路径\n```\n\n6、创建 supervisor 项目配置文件日志\n\n```shell\nsudo mkdir /var/log/supervisor\nsudo touch /var/log/supervisor/laravel-queue.log\nsudo chmod 777 /var/log/supervisor/laravel-queue.log\nsudo chown vagrant:vagrant /var/log/supervisor/laravel-queue.log\nsudo chown vagrant:vagrant /var/log/supervisor\n```\n## 启动 supervisor 项目配置文件\n\n```shell\nsudo supervisorctl reread   // 重新加载主配置文件\n\nsudo supervisorctl update // 创建项目配置文件进程组\n\nsudo supervisorctl start laravel-worker:*  // 启动监听进程\n\nsudo supervisorctl status  // 出现以下则成功\nlaravel-worker:laravel-worker_00   RUNNING   pid 12425, uptime 0:04:52\nlaravel-worker:laravel-worker_01   RUNNING   pid 12426, uptime 0:04:52\nlaravel-worker:laravel-worker_02   RUNNING   pid 12427, uptime 0:04:52\nlaravel-worker:laravel-worker_03   RUNNING   pid 12428, uptime 0:04:52\nlaravel-worker:laravel-worker_04   RUNNING   pid 12429, uptime 0:04:52\nlaravel-worker:laravel-worker_05   RUNNING   pid 12430, uptime 0:04:52\nlaravel-worker:laravel-worker_06   RUNNING   pid 12431, uptime 0:04:52\nlaravel-worker:laravel-worker_07   RUNNING   pid 12432, uptime 0:04:52\n\n```\n\n## Note\n\nLaravel Job 代码修改后，需要重启 supervisor 才会生效\n\n## Supervisor 命令\n\n```shell\nsudo supervisorctl status\nsudo supervisorctl stop usercenter\nsudo supervisorctl stop all   //  停止所有\nsudo supervisorctl start usercenter\nsudo supervisorctl restart usercenter\nsudo supervisorctl reread\nsudo supervisorctl update\nsudo supervisorctl  // 进入 cli\n```\n\n[官网](http://supervisord.org/running.html)：http://supervisord.org/running.html\n\n[原文连接](https://learnku.com/laravel/t/3592/using-supervisor-to-manage-laravel-queue-processes?#reply73153)：https://learnku.com/laravel/t/3592/using-supervisor-to-manage-laravel-queue-processes?#reply73153\n\n[参考连接](https://blog.tanteng.me/2017/01/supervisor-laravel-queue/)：https://blog.tanteng.me/2017/01/supervisor-laravel-queue\n\n[参考连接](https://blog.csdn.net/qq_28885149/article/details/79364685)https://blog.csdn.net/qq_28885149/article/details/79364685\n\n[supervisor Web管理界面与开房自启动](http://www.cnblogs.com/lemon-flm/articles/9283664.html)：http://www.cnblogs.com/lemon-flm/articles/9283664.html"},{"title":"什么是抽象","url":"/jingjie.github.io/2019/11/29/对象/","content":"\n# 抽象\n\n个人建议看百度百科更好，理由：\n\n- 相对维基百科百度百科对抽象的描述是高层抽象，维基是低层抽象。\n\n## 个人对抽象的理解\n\n分类、找规律、找关系的过程即是抽象过程，分类、找规律、找关系的结果即抽象的结果\n\n## 抽象的应用\n\n>人们之所以需要应用抽象法，**其客观的依据就在于自然界现象的『复杂性』和事物规律的『隐蔽性』**。假如说自然界的现象十分单纯，事物的规律是一目了然的，那倒是不必要应用抽象法，不仅抽象法成为不必要，就是整个科学也是多余的了。但是，实际情祝并非如此。科学的任务就在于透过错综复杂的现象，排除假象的迷雾，揭开大自然的奥秘，科学地解释各种事实。为此就需要撇开和排除那些偶然的因素，把普遍的联系抽取出来。这就是抽象的过程。不管是什么样的规律，什么样的因果联系，人们要发现它们，总是需要应用抽象法的。抽象法也同其他的各种科学思维的方法一样，对于科 学发现来说，起着一种助发现的作用。\n\n## 抽象分类\n\n#### 表征性抽象（低层抽象）\n\n百度百科原文：\n\n>所谓表征性抽象是以可观察的事物现象为直接起点的一种初始抽象，它是对物体所表现出来的特征的抽象。例如，物体的“形状”、“重量”、“颜色”、“温度”、“波长”等等，这些关于物体的物理性质的抽象，所概括的就是物体的一些表面特征。这种抽象就属于表征性的抽象。\n\n个人理解\n\n>是人对物体通过直观性来抽象的，同一种类或物体表现出的相同特征所做出的抽象，我把它叫做单类抽象。\n\n#### 原理性抽象（高层抽象）\n\n百度百科原文：\n\n>所谓原理性抽象，是在表征性抽象基础上形成的一种深层抽象，它所把握的是事物的 **因果性** 和 **规律性** 的联系。这种抽象的成果就是定律、原理。例如，杠杆原理、落体定律、牛顿的运动定律和万有引力定律，光的反射和折射定律、化学元素周期律、生物体遗传因子的分离定律、能的转化和守恒定律、爱因斯坦的相对性运动原理等等，都属于这种原理性抽象。\n\n个人理解\n\n>具有普遍性原理、非直观的、非常隐蔽的。如万有引力，它是对所有种类都管用，是一个跨种类的抽象，我把它叫做跨类抽象\n\n\n## 科学抽象的原则\n\n上面我们一般地考察了科学抽象的类型问题，那么，怎样才能合理地、有效地进行科学抽象呢?科学抽象应当注意以下的原则：\n\n#### 必须是普遍性的东西\n\n百度百科原文：\n\n>个别的、表面的东西是偶然的东西，要进行抽象，当然不能完全脱离这些个别的、表面的、偶然的东西，但是抽象的目的并不是去抽取那些个别的、偶然的东西，抽象的目的是在于从个别的经验事实中抽出普遍性的东西，只有这样才有意义，才能进一步去认识事物的规律性。当然，**普遍性不一定是规律性，但是不普遍的东西不可能是规律性的东西**。所以，什么东西需要抽象，什么东西不需要抽象，从定性的观点来看，应当抽象出普遍性的东西。比如从对空气的观察和实验的一系列事实中，抽象地认识存在于体积、温度以及压力之间的普遍关系，并进行定量的描述，这样也就发现了气体定律。\n\n#### 高层抽象的要求\n\n百度百科原文：\n\n>　自然界事物及其规律是多层次的系统，与此相应，科学抽象也是一个多层次的系统。在科学抽象的不同层次中，有低层的抽象，也有高层的抽象。在科学发现中，相对于解释性的理论原理来说，描述性的经验定律可以说是低层抽象，而解释性的理论原理就可以说是高层抽象。\n>\n>　必须指出，我们把科学抽象区分为低层抽象和高层抽象，是相对而言的。理论抽象本身也是多层次的。比如说，**牛顿的运动定律和万有引力定律相对于开普勒的行星运动三大定律来说，是高层抽象**，因为我们通过牛顿三大运动定律和万有引力定律的结合，就能从理论上推导出开普勒由观测总结得到的行星运动三大定律。\n>\n>　**如果高层抽象不能演绎出低层抽象，那就表明这种抽象并未真正发现了更普遍的定律和原理。一切普遍性较高的定律和原理，都能演绎出普遍性较低的定律和原理。一切低层的定律和原理都是高层的定律和原理的特例。如果一个研究者从事更高层的抽象，其结果无法演绎出低层抽象，那就意味着他所作的高层抽象是无效的，不合理的，应予纠正**。\n\n#### 思维抽象\n\n百度百科原文：\n\n>　抽象思维法是指在感性认识基础上运用概念、判断、推理等方式透过现象，抽取研究对象本质的理性思维法。具体地说，科学抽象就是人们在实践的基础上，对于丰富的感性材料通过“去粗取精、去伪存真、由此及彼、由表及里”的加工制作，形成概念、判断、推理等思维形式，以反映事物的本质和规律。\n>\n>　科学抽象是由三个阶段和两次飞跃构成的辩证思维过程。第一个阶段是感性的具体，即通过感官把事物的信息在大脑中形成表象。第二阶段是从感性到抽象的规定，也是第一次飞跃。这个阶段是将事物的表象进行分解、加工、分析和研究，最终形成反映事物不同侧面的各种本质属性。第三阶段是从抽象的规定上升到思维的具体，这是科学抽象的第二次飞跃。它是将事物的各种抽象规定在思维中加以综合、完整地重现出来，形成对事物内在本质的综合性的认识。\n\n#### 抽象解读\n\n百度百科原文：\n\n>　抽象就是将人们对世界万物的感觉，用特定的图像符号表达出来。因此要理解抽象的东西，就必需从内心感受它们。举例来说，“红色“这个词语本身，在你没有建立世间存在”色彩“这种概念以前，就是一个很抽象的东西，当我们第一次接触”红色“这个词语时，并不清楚，”红色“所表达是物体的”形状“，”大小“，”质地“，还是”颜色“，这是通过我们在生活中不断的从周围的环境中慢慢感知出来的。\n>\n>　简单来说，抽象就是将内心的感受使用一种特定的符号表示出来的”过程“。知道了什么是抽象后，那么”抽象画“就很好理解了，抽象画就是画家将自己的内心感觉通过特定的颜色和形状表现出来。这些”颜色“和”形状“，并不代表任何的某体事物，只是因为我们看到了这些”颜色“和”形状“，就是自然的激发内心的一种”美好的“或”忧伤的“以及某他的各种情绪感觉。","tags":["思想"]}]